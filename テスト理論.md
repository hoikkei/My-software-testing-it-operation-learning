
### 第一章 テスト理論
#### 1.1 ソフトウェアテストの概念
- Software Testing (ソフトウェアテスト)
指定された条件下でプログラムを操作（手動テスト、自動化テスト）して、プログラムのエラーを発見し、ソフトウェアの品質を測定し、要件を満たしているかどうかを評価します。

- ソフトウェアテストの目的
特定の目的、特定の方法で、エラー情報を報告し、エラー情報を追跡し、ソフトウェアの問題を発見し、システムがユーザーのニーズを満たしているか確認します。

- ソフトウェアテスト
テストは、ソフトウェアがユーザーのニーズに合致し、ソフトウェア品質基準を満たしているかどうかを確認するために、専門のテスト部門によって実行されます。

- 一般的なテスト活動には以下が含まれます：

-- 単体テスト：各コード関数をテストする
-- 統合テスト：コードのモジュールをテストする
-- システムテスト：各機能要件に対して、完全なテスト環境を設計し、テスト担当者が実行する

- ソフトウェア運用
この段階ではソフトウェアがリリースされ、ユーザーに提供され、メンテナンスフェーズに入ります。システムが正常に稼働していることを保証する必要があります。たとえば、ウェブサイトの24時間365日運用などです。ソフトウェアシステムには次のような問題が発生する可能性があります：

-- ユーザー増加によるパフォーマンス負荷
-- サーバーの問題によるシステムの利用不可
-- ソフトウェアのバグ
-- システムアップグレードによる未知のバグ
-- ユーザーが使用中に問題が発生した場合、技術サポート担当者にフィードバックされ、その後テストチームに送られ、開発チームが修正します。

#### 1.2 ソフトウェアテストのプロセス
- A.ビジネスプロセスに関連する人物
-- 開発エンジニア：バグを修正
-- プロダクトマネージャー：製品のビジネスプロセスに精通し、コミュニケーションを行う
-- カスタマーサービス/業務担当者：バグをテストに報告し、バグの確認を行う
-- 実装担当者/技術サポートエンジニア
-- デザイナー：要件を読み取り、理解し、ビジネスを学ぶ

- B.要件分析
要件点を整理する
疑問点があれば、会議で議論し、解決するまで続ける

- C.テスト計画
-- テストドキュメントの内容：目的性、期限性
-- テスト計画に参加する人員：王さん、李さん、張さん
-- タスク分割：誰がどの機能モジュールを担当するか、テストケースの作成
-- 時間計画：テストケースの準備時間、製品のリリーステスト時間
-- ドキュメント作成：テストケース、バグフォーム、ソフトウェアテストレポート
-- リソース申請：サーバーの数、テストタイプの分類、必要なリソースとツール

- D.テスト設計段階

-- 問題票を置く。合格の場合は進行し、不合格の場合は返送される
-- 全体のテストプロセスとバージョンの品質を評価し、リリース可能かどうかを確認する
- E.テスト通過、リリース
テストに合格しない場合、再テストに送られる

#### 1.3 ソフトウェアテストのワークフロー
- 1.ビジネスプロセスに関連する人物
-- 開発エンジニア：バグを修正
-- プロダクトマネージャー：製品のビジネスプロセスに精通し、コミュニケーションを行う
-- カスタマーサービス/業務担当者：バグをテストに報告し、バグの確認を行う
-- 実装担当者/技術サポートエンジニア
-- デザイナー：要件を読み取り、理解し、ビジネスを学ぶ
- 2.要件分析
要件点を整理する
疑問点があれば、会議で議論し、解決するまで続ける
- 3.テスト計画
-- テストドキュメントの内容：目的性、期限性
-- テスト計画に参加する人員：王さん、李さん、張さん
-- タスク分割：誰がどの機能モジュールを担当するか、テストケースの作成
-- 時間計画：テストケースの準備時間、製品のリリーステスト時間
-- ドキュメント作成：テストケース、バグフォーム、ソフトウェアテストレポート
-- リソース申請：サーバーの数、テストタイプの分類、必要なリソースとツール

- 4.テスト設計段階
テストケースの作成。要件ドキュメント、概要設計、詳細設計ドキュメントを参考にし、テストのカバレッジ、製品の安定性、使いやすさなどを評価する
- 5.テスト実行段階
テスト環境を構築し、テストを実施、検証する。欠陥管理プラットフォームに欠陥を提出し、バグが解決されるまで追跡する。バグが再現しないことを確認し、テストを終了する
- 6.テスト評価段階
問題票を置く。合格の場合は進行し、不合格の場合は返送される
全体のテストプロセスとバージョンの品質を評価し、リリース可能かどうかを確認する
- 7.テスト通過、リリース
テストに合格しない場合、再テストに送られる

#### 1.4 ソフトウェアテストモデル
ソフトウェアテストの発展に伴い、テスト担当者は多くの実践の中で、テスト活動を抽象化するいくつかのテストモデルをまとめました。Vモデルやウォーターフォール開発モデルは、共通の特性を持っています。Vモデルのプロセスは左から右へ進み、基本的な開発プロセスとテスト活動を説明しています。

Vモデルの価値は、テスト過程における異なるレベルの存在を非常に明確に示し、各テストフェーズと開発過程の各段階の対応関係をはっきりと説明している点にあります。
制限：テストをコーディング後の最後の活動とみなし、要件分析などの前段階で発生したエラーが、後の受け入れテストまで発見できないという問題があります。


HL
模型部分解释 单元测试 也叫做模块测试，进行正确性检查的工作。 单元测试要从程序内部结构设计测试用例，每个模块可以独立进行测试。 单元是什么？ 比如Python中的类 图形化软件的一个窗口，一个功能菜单 集成测试 也叫组装测试，也就是将所有单元测试，进行有序的组合测试
系统测试 将整个软件系统看做一个整体进行测试，对功能，性能，硬件，软件所有环节进行测试。 单元测试目的测试功能是否满足要求。 系统测试目的测试系统是否满足性能的要求，以及不同的机器系统平台中运行，如一台机器我登陆多个qq，是否可 以运行，在windows，linux平台运行qq是否正常等方面。
验收测试 α测试 Alpha测试模拟实际操作环境下验收测试，如删档内侧，软件只是初步完成的产品，bug可能较多，不会进行上线提供用户访问。 β测试 Beta测试系统已经通过内部测试，大部分错误已经修复，即将正式发布，在多个真实环境下发布，如不删档公测。 对比α版本已经有了较大改进，但仍可能存在一些bug，需要大规模测试，例如DNF公司更新一个地图，提供公测 免费下载，由专业游戏玩家进行游戏结果反馈，开发者啊、再进行修复。 y版本 y版本指的是正式版本，与上线版本几乎无区别。
软件测试的W模型
W模型优点:
测试伴随整个软件开发生命周期,更早接入测试,可以更好的发现需求设计中的缺陷,修复成本也更低.
W模型的缺点
依赖于软件开发和测试的前后线性关系,还是无法解决需求变更调整的问题.对于项目中不产出文档的事例,测试工作无法执行
对于复杂业务,新人不足以测试需求,测试设计.
测试覆盖率
覆盖率是用来度量测试完整性的一个手段,同时也是测试技术有效性的度量
覆盖率=(至少执行一次的项目点)/项目总数
特点:
通过覆盖率数据,检验测试工作是否充足
分析测试的弱点,对比测试人员的测试结果 翻译成日语怎么说


以下は日本語での説明です：

- モデル部分の説明

- 単体テスト
プログラムの正確性を確認するために行われる、モジュールテストとも呼ばれるテストです。
単体テストはプログラムの内部構造に基づいてテストケースを設計し、各モジュールを独立してテストすることができます。

- 単体とは何か？
例えば：

Pythonのクラス
GUIソフトウェアのウィンドウ
機能メニュー
結合テスト
組み立てテストとも呼ばれ、すべての単体テストを順序立てて組み合わせてテストすることです。

- システムテスト
ソフトウェアシステム全体を一つとして見てテストを行い、機能、性能、ハードウェア、ソフトウェアのすべての側面をテストします。
単体テストの目的は機能が要件を満たしているかを確認することです。
システムテストの目的は、システムが性能要件を満たしているか、また異なるマシンやシステムプラットフォームでの動作を確認することです。例えば、1台のマシンで複数のQQアカウントでログインできるか、WindowsやLinuxプラットフォームでQQが正常に動作するかなどです。

受け入れテスト：

- αテスト（アルファテスト）
実際の運用環境を模擬した受け入れテストです。データ削除を伴うクローズドベータテストのように、ソフトウェアは初期段階の製品で、バグが多く存在する可能性があり、ユーザーへの一般公開は行いません。

- βテスト（ベータテスト）
システムが内部テストを通過し、大部分のエラーが修正され、正式リリース直前の段階です。複数の実環境でリリースされ、オープンベータテストのような形で行われます。αバージョンと比較して大幅な改善が見られますが、まだバグが存在する可能性があり、大規模なテストが必要です。例えば、DNF社が新しいマップをアップデートし、ベータテスト版を無料配布して、プロゲーマーからのフィードバックを基に開発者が修正を行います。

- γバージョン
正式版を指し、リリース版とほぼ同じものです。

Wモデルのソフトウェアテスト

- Wモデルの利点：

テストがソフトウェア開発ライフサイクル全体に伴い、早期にテストを導入することで、要件設計の欠陥をより良く発見でき、修正コストも低くなります。
Wモデルの欠点：

ソフトウェア開発とテストの前後の線形関係に依存し、要件変更の問題を解決できません。
プロジェクトでドキュメントが作成されない場合、テスト作業を実行できません。
複雑なビジネスロジックに対して、新人では要件やテスト設計のテストが十分にできません。
テストカバレッジ
カバレッジはテストの完全性を測定する手段であり、同時にテスト技術の有効性の指標でもあります。

カバレッジ = (少なくとも1回実行されたプロジェクトポイント) / プロジェクトの総数

- 特徴：

カバレッジデータを通じてテスト作業が十分かどうかを検証
テストの弱点を分析し、テスト担当者のテスト結果を比較



### 第2章 テスト分類
テストの基本分類
機能テスト - 手動でマウスを使用してテストする（GUIテスト）、クリックによるテスト
自動化テスト - プログラムでプログラムをテストする（APIテスト）、手作業から解放
性能テスト - システムのボトルネックを特定し、システムの性能と安定性を確保
ブラックボックステスト - アプリケーションの機能をテストし、結果が正しいかを検証
ホワイトボックステスト - プログラムの内部構造をテストし、プログラミング言語の観点からテストケースを設計

#### 2.1 ソフトウェアテスト機能分類
テストフェーズによる分類：

単体テスト（Unit Testing）
結合テスト（Integration Testing）
システムテスト（System Testing）

単体テスト
単体とは何か？メモリモジュールを一つの単位として理解できる、一つの機能小モジュール
単体テストは基本単位（ソフトウェア設計の最小単位）に対する正確性検証作業です。
単体テストの目的は、ソフトウェアモジュールが要件設計書の要求を満たしているかを検証することです。
結合テスト
結合テストは単体テストを基礎とし、すべてのモジュールを設計通りにサブシステムとして組み立てて検証します。
システムテスト
テスト作業員の配置、テスト環境の構成、コンピュータハードウェア環境の構成を統合して、テスト作業を実施します。
単体・結合・システムテストの違い
テスト方法の違い：

単体テストはホワイトボックステストの範疇
結合テストはグレーボックステストの範疇
システムテストはブラックボックステストの範疇

テスト範囲の違い

単体テストは単位内部のデータ構造、論理制御、例外処理などを検査
結合テストはモジュール間のデータ転送を検査
システムテストはソフトウェア全体が要件を満たしているかを検査

#### 2.2 リグレッションテスト
テストプロセス情報フロー
ソフトウェア環境構成：要件文書、要件設計書、テストコードなど
テスト環境構成：テスト要件仕様書、テスト計画書、テストケースなど

リグレッションテストの定義
ソフトウェアのテストまたは他の活動で欠陥が発見され、修正された後に実施すべきテスト活動です。
目的は欠陥が正しく修正されたか、また他の機能に影響を与えていないかを検証することです。
リグレッションテストのプロセス

テスト戦略とリグレッションテスト戦略の策定
リグレッションテストバージョンの確定
リグレッションテスト戦略に基づくテストの実行
リグレッションテストが合格した場合、欠陥追跡票を終了（禅道）
リグレッション不合格の場合、欠陥追跡票を開発者に返却し、再修正後に再度リグレッション

リグレッションテスト戦略の設計
完全再テスト：

以前に定義されたすべてのテストケースを再実行し、修正の正確性と影響範囲を確認

選択的再テスト：

一部のテストケースを選択して再実行
修正範囲カバレッジ法：修正された部分に対して新しいテストケースを構築
影響波及法：修正による間接的な影響の有無を分析
目標達成法：テストケースカバレッジ率などの目標を設定

自動化リグレッションテスト
リグレッションテストの特性上、以前の成果を再実行し、何回のリグレッションが必要か予測できないため、テスト担当者のモチベーション低下やテスト品質の低下を防ぐため、自動化が必要です。
良好な自動化リグレッションテストには以下が含まれます：

プログラムの自動実行
プログラムパラメータの自動設定
テストケースの自動管理
テスト活動の自動実行
テスト情報ログの自動収集
テスト結果の自動分析と出力

#### 2.3 受け入れテスト
ソフトウェアライフサイクルにおいて、開発段階では単体テスト、結合テスト、システムテストなど企業内部でのテスト活動が含まれます。
ソフトウェアリリース前に、実際のユーザーが参加するテスト活動があり、これを受け入れテストと呼びます。
ソフトウェアプロジェクト開発には2つの形式があります：

企業自社製品

リリース前にユーザーが参加する大規模なベータテスト、パブリックテスト
αテスト
βテスト


受託開発

顧客の要件に基づいて開発
製品開発後、顧客による検収で要件の正確性を確認

#### 2.4 αテストとβテスト
αテスト

ゲームの削除を伴うクローズドベータテストに相当
企業内部の従業員が実環境をシミュレートしてテストを実施し、フィードバックを行う
開発者の指導のもと、ソフトウェアを使用し、使用過程でのエラーを記録
FLURPSの評価が目的（機能性、局所化、使用性、信頼性、性能、サポート性）
非公式な受け入れテストとして、特に製品のインターフェースと特徴を重視

βテスト

ゲームのオープンベータテストに相当
複数のユーザーが実際の操作環境（異なる端末、プラットフォーム、ネットワーク環境など）でテスト
開発者の管理外で自主的にテストを実施し、結果をフィードバック

#### 2.5 テストの区分
テストは4つの主要段階に分かれる：

テスト計画
テスト方式
テストケース
テストレポート

#### 2.6 ブラックボックステスト
特徴：

機能テストとも呼ばれ、プログラムの各機能を順序通りに検査
ソフトウェアのインターフェースと機能をテスト、内部実装は考慮しない
説明書やユーザーマニュアルに基づいて機能テストを実施
テレビのリモコンのように、内部構造に関係なく機能の確認のみ
正確なレポートを得るには多くのデータと複数回のテストが必要

ブラックボックステストの種類：

機能性テスト：Webサイトの機能順序、携帯電話の機能、ディスプレイの正常表示など
容量テスト：大量データの処理（例：1億人のWeChat利用者）
負荷テスト：短時間での大量データ処理時のシステム健全性指標
回復性テスト：システム障害時のユーザーデータへの影響

#### 2.7 ホワイトボックステスト
特徴：

ソースコードの内部を確認可能
ブラックボックステストより厳密で、ソースコードとアーキテクチャをテスト
ソースコードやフローチャートなどの設計文書が必要
プログラム内部構造に基づきテストケースを設計
プログラム構造に基づく論理駆動テスト


#### 2.8 ソフトウェアテスト方法の選択
テスト方法の選択基準

製品要件仕様は知っているが内部実装を知らない場合：ブラックボックステストで要件の実現を証明
製品内部実装を知っている場合：各内部操作が要件に適合しているかをホワイトボックステストで確認

ホワイトボックステストが必要な理由

基本要件の検証だけでは不十分
より高いカバレッジ率を達成可能
隠れた欠陥を発見可能
ソフトウェア品質により高い保証を提供

ホワイトボックステストの特徴

ソフトウェア要件の理解
ソースコードの実装理解
コードロジックの検証
コード内のファイルパスの検証
比較的高いコスト

ホワイトボックステストの方法

静的分析

制御フロー分析
データフロー分析
情報フロー分析


動的分析

ロジックカバレッジテスト（分岐テスト、パステスト）
プログラム計装



ロジックカバレッジテスト

文カバレッジ
判定カバレッジ
条件カバレッジ
パスカバレッジ

プログラム計装
デバッグ時のprint()文のように、プログラムの動的情報を取得する技術
ブラックボックステストの利点

比較的簡単で、内部コードや実装を理解する必要なし
ソフトウェアの内部実装と無関係
ユーザー視点からの機能確認が容易
開発文書に基づく機能確認が可能
自動化テストが比較的容易

ブラックボックステストの欠点

明確なテスト仕様がない場合、テストケース設計が困難
自動化テストの再利用性が低い
プログラム内部パスの制御が不可能

グレーボックステスト

ブラックボックスとホワイトボックスの中間
テスト対象の情報に応じて異なるテスト方法を採用
全体特性と内部実装の両方を考慮

ソフトウェアテストドキュメント
テスト文書の種類：

要件分析：テストの根拠
概要設計：要件カバレッジの確認
詳細設計：方式、戦略、アーキテクチャ、インターフェース等
テスト設計：テスト内容と機能点の定義
テストケース：テストの基準と規範
テストレポート：成功数、失敗数、テスト結果等

静的テストと動的テスト

静的テスト：ソフトウェアを実行せずにコードレビュー等で実施
動的テスト：計画されたテストデータとフローに従って実施




### 第 3 章 テスト要件
3.1 ソフトウェアテスト要件
ソフトウェア要件分析（Software Requirement Analysis）は、ユーザーの要件を完全に理解し、ユーザーのソフトウェア機能要件を確認し、確認可能で受け入れ可能な基本的な根拠を確立するための研究成果です。
ソフトウェアテスト要件は、テストケースを設計するための基準です。
テストの品質を保証し、テストカバレッジの指標を測定します。
要するに、どのようにテストするか、いつテストするか、どれだけの人員と物資が必要かを明確にすることです。
ソフトウェアテスト要件分析
開発するソフトウェアの種類、要件の出所、製品のユーザー層に基づいて、異なる対象の要件を分析します。
特定の製品の開発に向けて
要件の出所：市場分析、市場調査
ユーザー層：市場調査担当者
要件の特徴：市場の動向に基づいて、主流の製品を開発します。
特定の市場向けの開発に向けて
要件の出所：顧客の要件
ユーザー：指定されたクライアント
要件の特徴：市場の動向に基づいて、主流の製品を開発します。
特定のプロジェクトの開発に向けて
要件の出所：顧客の要件
ユーザー：指定されたクライアント
要件の特徴：顧客が求めるものを作成します。
テスト要件分析の設計
要件文書に基づいてテストポイントを抽出し、テストポイントに基づいてテストケースを作成します。
テストの要点分析：
正確性、必要性、優先度、明確性、完全性、修正可能性、一貫性
要件記述の入力、出力、処理、制限、制約などを分析し、対応する検証内容を提供します。これを機能テストと呼びます。
モジュール間の業務順序、各機能モジュール間で伝達される情報とデータを分析し、相互機能が存在する機能項目に対して対応する検証結果を提供します。これを機能相互テストと呼びます。
要件の完全性を考慮し、ソフトウェア要件のさまざまな特定を十分にカバーし、インターフェースの検証、アカウント登録の一意性の検証などの隠れた要件の検証を含みます。テストの観点は、インターフェース、使いやすさ、互換性、安全性、性能ストレスです。


### 第四章 テスト分類
- 4.1 テスト計画とは何か
テスト計画は、予定されたテスト活動の範囲、方法、リソース、およびスケジュールを記述した文書です。
この文書は、テスト項目、テストされる特性、テストタスク、人的配置、および偶発的なリスクを確認します。
プロジェクトおよび製品に関する情報を収集し、テスト範囲およびテストリスクを分析し、テストケース、作業量、リソース、および時間を見積もり、テスト戦略、方法、環境、リソース、およびスケジュールを合理的に計画します。
プロジェクト成功の要素
以下の 4 つの要素：時間、コスト、範囲、品質
時間はプロジェクト全体の計画でカバーされます。
コストは契約でカバーされ、クライアントがカスタマイズします。
範囲は要件文書でカバーされます。
品質は QA 計画またはテスト計画でカバーされます。
なぜテスト計画を定めるのか
規則がなければ、秩序は成り立ちません。
テスト計画をカスタマイズすることで、ソフトウェアテストは計画的で組織的なソフトウェア品質保証活動となります。計画がないと、作業が散漫で任意になります。

- 4.2 テスト戦略
全体的なテスト戦略
どのテスト方法を使用するか？ブラックボックステストを実行するか、ホワイトボックスや自動化が必要か？
各段階のテスト作業の重点を規定する
テストの開始 / 中断 / 完了の基準
どの基準に適合すればテストを開始できるか
どの基準に適合すればテストを中断または一時停止しなければならないか
どの基準に適合すればテストを終了できるか
テストタイプの定義
機能テスト
インストール・アンインストールテスト
互換性テスト
ユーザビリティテスト
テスト技術
ブラックボックステストツール
ホワイトボックステストツール
自動化スクリプトの作成



### 第五章 欠陥管理
#### 5.1 欠陥とは何か
ソフトウェアにおいてユーザーの要件を満たさない問題はすべてソフトウェアの欠陥として識別されます。
製品の内部から見ると、欠陥は製品開発または保守中に存在するエラーや異常などの問題です。
製品の外部から見ると、欠陥は特定の機能の実現に違反しています。

#### 5.2 欠陥識別方法
ユーザーエクスペリエンスが悪く、フィードバックがある
インターフェースに明らかなエラーメッセージがある
機能が欠落しており、要件仕様書に一致しない
プログラムがクラッシュして停止する
プログラムのロジックが正しくなく、ユーザーマニュアルと一致しない
プログラムの性能が悪く、負荷アクセスに耐えられない

#### 5.3 欠陥の原因
要件の原因
要件が絶えず変化する
工期が短く、ソフトウェアが複雑
コーディング中のエラー
設計文書が不完全
コミュニケーションが少ない
ハードウェアとソフトウェアがサポートしない

#### 5.4 一般的なソフトウェア欠陥用語
バグ（bug）：ソフトウェアプログラムの欠陥や不具合を指す総称。
デバッグ（Debug）：コンピュータプログラムや電子機器

#### 5.5 欠陥の種類
A. 機能の欠如
指定された時間や機能が製品システムに存在しないこと。例えば、パスワードを忘れた場合の機能が欠如している。
B. プログラムエラー
ユーザーの要件に正しく応じていないこと。要件の理解ミスやコーディングミスが考えられる。
C. 追加の機能
ユーザーの要件に含まれていない機能が実装されていること。

#### 5.6 欠陥の再現
再現可能な欠陥は、一連の明確な再現操作手順、条件、データがあり、欠陥が安定して繰り返し発生する。
再現不可能な欠陥は、明確な手順が見つからず、欠陥の発生がランダムである。記録のみを行い、報告はしない。
再現不可能な欠陥は、後にさらに深く掘り下げて、再現可能な欠陥に変換し、欠陥報告を行う。

#### 5.7 欠陥報告
欠陥報告は、テストの実行中に発見されたソフトウェア欠陥を記録する文書であり、開発者やテスト責任者に提供され、欠陥の特定の基準として使用される。また、欠陥の数を統計するための重要な基準でもある。
正確で完全、簡潔な欠陥報告を提供することは、ソフトウェアテストの専門性と高品質の評価基準である。

#### 5.8 欠陥報告の 5C 原則
5C 原則
Correct（正確）：各要素の記述が正確で、誤解を招かないこと。
Clear（明確）：各要素の記述が明確
で、理解しやすいこと。
Concise（簡潔）：必要不可欠な情報のみを含み、余分な内容を含まないこと。
Complete（完全）：欠陥を再現するための完全な手順とその他の重要な情報を含むこと。
Consistent（一貫）：すべての欠陥報告を一貫した形式で記述すること。
欠陥報告の構造
報告する欠陥情報が具体的で正確
欠陥の特性説明と再現手順
欠陥の種類と重大度
欠陥のタイトル
欠陥の基本情報
テスト環境の説明
欠陥の重大度
欠陥報告の注意点
欠陥発生の原因と結果に基づいて記述
曖昧な言葉を避ける、例えば「機能が正しくない」、「ログインができない」など。具体的にどの機能がどう正しくないのか、ログインの具体的な手順がどう間違っているのかを記述。
中立的な評価を行い、ソフトウェア欠陥に対する理解を公正に表現し、ソフトウェアのエラーとその結果を記述。

#### 5.9 一般的なソフトウェア欠陥
一般的なソフトウェア欠陥には以下のようなものがあります：
機能の欠如：必要な機能が実装されていない。
プログラムエラー：コードのバグやロジックエラー。
ユーザインターフェースの問題：UI がユーザーにとって使いにくい。
性能問題：システムのレスポンスが遅い、または負荷に耐えられない。
セキュリティ欠陥：データ漏洩や不正アクセスのリスクがある。
互換